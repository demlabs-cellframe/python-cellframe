"""
üí∞ Cellframe Transaction (TX) Module

Low-level transaction operations for working with dap_chain_tx_t structures.
This module provides direct access to transaction manipulation functions
without high-level composition logic.

For transaction creation, use the Composer module instead.
"""

import threading
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any
from decimal import Decimal

from ..core import CellframeException

# Registry for transaction instances
_tx_registry: Dict[int, 'TX'] = {}
_registry_lock = threading.RLock()

# Try to import cellframe if available
# Import native functions with conditional availability check
try:
    import python_cellframe as cf_native
    
    # Centralized check for all required transaction functions - ONCE at import
    required_functions = [
        'dap_chain_datum_tx_create',
        'dap_chain_datum_tx_add_in_item',
        'dap_chain_datum_tx_add_out_ext_item',
        'cf_native.dap_chain_datum_tx_add_sign_item',
        'dap_chain_datum_tx_verify',
        'dap_chain_datum_tx_get_size',
        'dap_chain_mempool_tx_put',
        'dap_chain_mempool_tx_get_by_hash'
    ]
    
    missing_functions = [func for func in required_functions if not hasattr(cf_native, func)]
    if missing_functions:
        raise ImportError(
            f"‚ùå CRITICAL: Missing native transaction functions: {', '.join(missing_functions)}\n"
            "This is a Python bindings library - all transaction functions must be implemented.\n"
            "Please implement these functions in src/cellframe_tx.c"
        )
    
    # Use DapSign directly from native module when needed

except ImportError as e:
    # Check for test mode - allow imports in test environment
    import os
    if os.getenv('CELLFRAME_TEST_MODE') == '1':
        print(f"‚ö†Ô∏è WARNING: TX module running in test mode, some functions may not be available: {e}")
        # Create minimal stubs for testing
        cf_native = None
    else:
        raise ImportError(
            "‚ùå CRITICAL: Native python_cellframe module not available!\n"
            f"Original error: {e}\n"
            "Please ensure python_cellframe native module is properly built and installed."
        ) from e


class TxError(CellframeException):
    """Transaction operation error"""
    pass


class TxType(Enum):
    """–¢–∏–ø—ã —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π —Å–æ–≥–ª–∞—Å–Ω–æ —Ä–µ–∞–ª—å–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ Cellframe"""
    TRANSFER = "transfer"           # –û–±—ã—á–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥
    STAKE_ORDER = "stake_order"     # –°—Ç–µ–π–∫–∏–Ω–≥
    VOTE = "vote"                   # –ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ
    DECREE = "decree"               # –£–∫–∞–∑—ã
    CONDITIONAL = "conditional"     # –£—Å–ª–æ–≤–Ω—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    SHARED_WALLET = "shared_wallet" # Shared –∫–æ—à–µ–ª–µ–∫
    EXCHANGE = "exchange"           # –û–±–º–µ–Ω —Ç–æ–∫–µ–Ω–æ–≤
    BRIDGE = "bridge"               # –ú–µ–∂—Å–µ—Ç–µ–≤–æ–π –º–æ—Å—Ç


class TxStatus(Enum):
    """–°—Ç–∞—Ç—É—Å—ã —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π"""
    PENDING = "pending"             # –û–∂–∏–¥–∞–µ—Ç –≤ mempool
    CONFIRMED = "confirmed"         # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ –≤ –±–ª–æ–∫—á–µ–π–Ω–µ
    FAILED = "failed"               # –ü—Ä–æ–≤–∞–ª–µ–Ω–∞
    REJECTED = "rejected"           # –û—Ç–∫–ª–æ–Ω–µ–Ω–∞
    EXPIRED = "expired"             # –ò—Å—Ç–µ–∫–ª–∞


class TxInput:
    """Transaction input reference"""
    def __init__(self, tx_hash: str, out_index: int, value: int, token_ticker: str):
        self.tx_hash = tx_hash
        self.out_index = out_index
        self.value = value
        self.token_ticker = token_ticker

    def to_dict(self) -> Dict[str, Any]:
        return {
            'tx_hash': self.tx_hash,
            'out_index': self.out_index,
            'value': self.value,
            'token_ticker': self.token_ticker
        }


class TxOutput:
    """Transaction output definition"""
    def __init__(self, address: str, value: int, token_ticker: str):
        self.address = address
        self.value = value
        self.token_ticker = token_ticker

    def to_dict(self) -> Dict[str, Any]:
        return {
            'address': self.address,
            'value': self.value,
            'token_ticker': self.token_ticker
        }


class TX:
    """
    üí∞ Low-level Transaction Operations
    
    Represents a dap_chain_tx_t structure and provides direct access
    to transaction manipulation functions. This class does NOT create
    transactions - it only works with existing transaction handles.
    
    For transaction creation, use the Composer module.
    """
    
    def __init__(self, tx_handle: Any, owns_handle: bool = True):
        if tx_handle is None:
            raise TxError("tx_handle –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å None")
            
        self._tx_handle = tx_handle
        self._owns_handle = owns_handle
        self._is_finalized = False
        self.hash = ""
        self.type = TxType.TRANSFER
        self.status = TxStatus.PENDING
        self.inputs: List[TxInput] = []
        self.outputs: List[TxOutput] = []
        self.fee = 0
        self.token_ticker = ""  # –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´–ô –ø–∞—Ä–∞–º–µ—Ç—Ä!
        self.created_at = datetime.now()
        self.confirmed_at = None
        self.signatures = []
        
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä
        with _registry_lock:
            _tx_registry[id(self)] = self
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.finalize()
    
    @classmethod
    def from_raw(cls, raw_tx_data: bytes) -> 'TX':
        """–°–æ–∑–¥–∞—Ç—å TX –∏–∑ raw –¥–∞–Ω–Ω—ã—Ö"""

            
        try:
            # –ü–∞—Ä—Å–∏–º raw –¥–∞–Ω–Ω—ã–µ –≤ dap_chain_datum_tx_t
            tx_handle = cf_native.dap_chain_datum_tx_create()
            if not tx_handle:
                raise TxError("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –∏–∑ raw –¥–∞–Ω–Ω—ã—Ö")
                
            # –ó–¥–µ—Å—å –Ω—É–∂–Ω–∞ —Ä–µ–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏
            # –ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–≥–ª—É—à–∫—É
            transaction = cls(tx_handle, owns_handle=True)
            transaction.type = TxType.TRANSFER
            
            return transaction
        except Exception as e:
            raise TxError(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏–∑ raw –¥–∞–Ω–Ω—ã—Ö: {e}")
    
    def add_input(self, tx_hash: str, out_index: int, value: int, token_ticker: str):
        """–î–æ–±–∞–≤–∏—Ç—å –≤—Ö–æ–¥ –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é"""
        if not token_ticker:
            raise TxError("token_ticker –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–∫–∞–∑–∞–Ω!")
            
        input_item = TxInput(tx_hash, out_index, value, token_ticker)
        self.inputs.append(input_item)
        

            
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –†–ï–ê–õ–¨–ù–£–Æ —Ñ—É–Ω–∫—Ü–∏—é –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—Ö–æ–¥–∞
            cf_native.dap_chain_datum_tx_add_in_item(
                self._tx_handle,
                tx_hash.encode(),
                out_index,
                value
            )
        except Exception as e:
            raise TxError(f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—Ö–æ–¥–∞: {e}")
    
    def add_output(self, address: str, value: int, token_ticker: str):
        """–î–æ–±–∞–≤–∏—Ç—å –≤—ã—Ö–æ–¥ –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é"""
        if not token_ticker:
            raise TxError("token_ticker –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–∫–∞–∑–∞–Ω!")
            
        output_item = TxOutput(address, value, token_ticker)
        self.outputs.append(output_item)
        

            
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –†–ï–ê–õ–¨–ù–£–Æ —Ñ—É–Ω–∫—Ü–∏—é –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—ã—Ö–æ–¥–∞
            cf_native.dap_chain_datum_tx_add_out_ext_item(
                self._tx_handle,
                address.encode(),
                value,
                token_ticker.encode()  # –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´–ô –ø–∞—Ä–∞–º–µ—Ç—Ä —Ç–æ–∫–µ–Ω–∞!
            )
        except Exception as e:
            raise TxError(f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—ã—Ö–æ–¥–∞: {e}")
    
    def sign(self, signature: Any):
        """–ü–æ–¥–ø–∏—Å–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é"""
        if not signature:
            raise TxError("–ü–æ–¥–ø–∏—Å—å –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å None")
            
        self.signatures.append(signature)
        

            
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –†–ï–ê–õ–¨–ù–£–Æ —Ñ—É–Ω–∫—Ü–∏—é –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∏
            if hasattr(signature, 'get_signature_data'):
                sign_data = signature.get_signature_data()
            else:
                sign_data = signature
                
            cf_native.dap_chain_datum_tx_add_sign_item(
                self._tx_handle,
                sign_data,
                len(sign_data)
            )
        except Exception as e:
            raise TxError(f"–û—à–∏–±–∫–∞ –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {e}")
    
    def verify(self) -> bool:
        """–í–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é"""

            
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –†–ï–ê–õ–¨–ù–£–Æ —Ñ—É–Ω–∫—Ü–∏—é –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏
            result = dap_chain_datum_tx_verify(self._tx_handle)
            return result == 0
        except Exception as e:
            raise TxError(f"–û—à–∏–±–∫–∞ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {e}")
    
    def get_size(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏"""

            
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –†–ï–ê–õ–¨–ù–£–Æ —Ñ—É–Ω–∫—Ü–∏—é –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
            size = dap_chain_datum_tx_get_size(self._tx_handle)
            return int(size)
        except Exception as e:
            raise TxError(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {e}")
    
    def broadcast(self, chain_handle: Any, hash_out_type: str = "hex") -> str:
        """
        –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ mempool
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –†–ï–ê–õ–¨–ù–£–Æ —Ñ—É–Ω–∫—Ü–∏—é dap_chain_mempool_tx_put!
        """
        if self._is_finalized:
            raise TxError("–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —É–∂–µ —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
            
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –†–ï–ê–õ–¨–ù–£–Æ —Ñ—É–Ω–∫—Ü–∏—é –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ mempool
            result = dap_chain_mempool_tx_put(
                chain_handle,
                self._tx_handle,
                hash_out_type.encode()
            )
            
            if result:
                self.status = TxStatus.PENDING
                self.hash = result.decode() if isinstance(result, bytes) else str(result)
                return self.hash
            else:
                raise TxError("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ mempool")
                
        except Exception as e:
            raise TxError(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {e}")
    
    def to_dict(self) -> Dict[str, Any]:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ —Å–ª–æ–≤–∞—Ä—å"""
        return {
            'hash': self.hash,
            'type': self.type.value,
            'status': self.status.value,
            'token_ticker': self.token_ticker,
            'fee': self.fee,
            'created_at': self.created_at.isoformat(),
            'confirmed_at': self.confirmed_at.isoformat() if self.confirmed_at else None,
            'inputs': [inp.to_dict() for inp in self.inputs],
            'outputs': [out.to_dict() for out in self.outputs],
            'signatures_count': len(self.signatures),
            'size': self.get_size()
        }
    
    def finalize(self):
        """–§–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é"""
        if self._is_finalized:
            return
            
        try:
            # –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            self._is_finalized = True
            
            # –£–±–∏—Ä–∞–µ–º –∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞
            with _registry_lock:
                _tx_registry.pop(id(self), None)
                
        except Exception as e:
            raise TxError(f"–û—à–∏–±–∫–∞ —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {e}")
    

    
    def __del__(self):
        if not self._is_finalized:
            self.finalize()


# Utility functions for working with transactions
def get_tx_by_hash(tx_hash: str) -> Optional[TX]:
    """–ü–æ–ª—É—á–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –ø–æ —Ö–µ—à—É –∏–∑ mempool"""

        
    try:
        tx_handle = dap_chain_mempool_tx_get_by_hash(tx_hash.encode())
        if tx_handle:
            tx = TX(tx_handle, owns_handle=True)
            tx.hash = tx_hash
            return tx
    except Exception:
        pass
        
    return None


def broadcast_tx(tx: TX, chain_handle: Any) -> str:
    """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ —Å–µ—Ç—å"""
    return tx.broadcast(chain_handle)


__all__ = [
    'TX',
    'TxError',
    'TxType',
    'TxStatus',
    'TxInput',
    'TxOutput',
    'get_tx_by_hash',
    'broadcast_tx'
] 